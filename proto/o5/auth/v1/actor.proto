syntax = "proto3";

package o5.auth.v1;

import "buf/validate/validate.proto";
import "google/protobuf/timestamp.proto";

option go_package = "github.com/pentops/o5-auth/gen/o5/auth/v1/auth_pb";

message Actor {
  oneof type {
    AuthenticatedActor authenticated = 1;
    NamedActor named = 2;
  }

  message NamedActor {
    string name = 1;
  }
}

message AuthenticatedActor {
  // The unique identifier of the actor, derived from the various actor type
  // methods.
  string id = 1 [(buf.validate.field).string.uuid = true];

  ActorType type = 2 [(buf.validate.field).required = true];

  Claim claim = 3 [(buf.validate.field).required = true];

  // Arbitrary tags that are defined by the authorizing system to quickly
  // identify the user e.g. the user's email address, API Key Name, etc.
  // Must not be used in authorization logic, and should not be used as a
  // the primary source of the actor's identity.
  map<string, string> actor_tags = 4;
}

message ActorType {
  oneof type {
    UserAgent user_agent = 1;
    ApiClient api_client = 2;
  }

  // A (presumably) human user using a web browser or mobile app.
  message UserAgent {
    ClientAuthType client_auth = 1;

    // The provided user agent string of the client.
    string user_agent = 2;

    // The IP address of the client as best as can be determined
    string ip_address = 3;
  }

  message ApiClient {
    ClientAuthType client_auth = 1;

    // The IP address of the client as best as can be determined
    string ip_address = 2;
  }
}

message ClientAuthType {
  oneof type {
    JWTAuth jwt = 1;
    SessionAuth session = 2;
  }

  message JWTAuth {
    string jwt_id = 1;
    string issuer = 2;
    google.protobuf.Timestamp issued_at = 3;
  }

  message SessionAuth {
    // The identity of the system which stored and evaluated the session.
    string session_manager = 1;

    // The session ID as defined by the session manager
    string session_id = 2;

    // The time at which the session was verified by the session manager.
    google.protobuf.Timestamp verified_at = 3;

    // The time at which the session began at the session manager. (e.g. the
    // time a refresh token was used to create a new session)
    google.protobuf.Timestamp authenticated_at = 4;
  }
}

message Claim {
  // 'Tenant Entities' in the system represent an organization or group with
  // ownership, responsibility or control of 'Resource Entities'. The various
  // ways in which these associacions are moddled is up to the application code,
  // but can be called 'owned by', if slightly inaccurately, for simplification,
  // but this does not imply a single owner or even a chain of ownership.
  // Resource Entities are owned by Tenant Entities either directly,
  // or indirectly via relationships with other entities, including other Tenant
  // Entities (e.g. where a 'User' is both a Tenant, and a Resource which an
  // 'Organization' can manage, resources belonging to the 'User' also belong to
  // the 'Organization').
  //
  // Code within the pentops paradeigms (o5, j5) store the list of tenants with
  // the resource entity, e.g. in protostate StateKeys.
  //
  // All code enforcing or granting access must follow the following rules:
  //
  // - Entities can have multiple owners,
  // - Ownership is immutable.
  // - No entries = No access to anything, basically useless.
  // - One entry: Access to all resource entities 'owned by' the tenant entity
  // - Multiple entries: Access only to Resource Entities jointly owned by all
  //   listed Tenant Entities.
  //
  // Keys are defined by the application code, representing the 'type' of tenant,
  // e.g. 'account', 'organization' etc, and should be treated like an enum.
  // Whilst not required by any pentops code, the tenant keys should be globally
  // unique, e.g. a URI (e.g. 'claims.example.com/account')
  map<string, string> tenant = 1 [(buf.validate.field).map.values.string.uuid = true];

  repeated string scopes = 2;
}
